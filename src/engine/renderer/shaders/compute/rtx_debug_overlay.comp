#version 450

layout(local_size_x = 8, local_size_y = 8) in;

// Input debug data
layout(set = 0, binding = 0) uniform sampler2D depthBuffer;
layout(set = 0, binding = 1) uniform sampler2D normalBuffer;
layout(set = 0, binding = 2) uniform sampler2D motionVectors;
layout(set = 0, binding = 3) uniform sampler2D rtOutput;

// Output overlay image
layout(set = 0, binding = 4, rgba8) uniform image2D overlayImage;

// Lighting contribution buffers (for RTX debug)
layout(set = 0, binding = 5) uniform sampler2D directLightBuffer;   // Direct lighting
layout(set = 0, binding = 6) uniform sampler2D indirectLightBuffer; // GI/indirect
layout(set = 0, binding = 7) uniform sampler2D lightmapBuffer;      // Lightmap data

// Debug modes enum
#define DEBUG_MODE_OFF 0
#define DEBUG_MODE_DEPTH 1
#define DEBUG_MODE_NORMALS 2
#define DEBUG_MODE_MOTION 3
#define DEBUG_MODE_RT_OUTPUT 4
#define DEBUG_MODE_HEATMAP 5
#define DEBUG_MODE_LIGHTING_CONTRIB 6
#define DEBUG_MODE_MATERIAL_PROPS 7
#define DEBUG_MODE_RAY_DENSITY 8

// Push constants for debug mode selection
layout(push_constant) uniform PushConstants {
    uint debugMode;  // Debug mode from enum above
    float scale;     // Visualization scale factor
    float threshold; // Debug threshold value
    uint flags;      // Additional debug flags
} pc;

// Color mapping functions
vec3 depthToColor(float depth) {
    // Map depth to rainbow gradient
    float d = clamp(depth * pc.scale, 0.0, 1.0);
    vec3 color;
    if (d < 0.25) {
        color = mix(vec3(0, 0, 1), vec3(0, 1, 1), d * 4.0);
    } else if (d < 0.5) {
        color = mix(vec3(0, 1, 1), vec3(0, 1, 0), (d - 0.25) * 4.0);
    } else if (d < 0.75) {
        color = mix(vec3(0, 1, 0), vec3(1, 1, 0), (d - 0.5) * 4.0);
    } else {
        color = mix(vec3(1, 1, 0), vec3(1, 0, 0), (d - 0.75) * 4.0);
    }
    return color;
}

vec3 normalToColor(vec3 normal) {
    // Map normal from [-1, 1] to [0, 1] for visualization
    return normal * 0.5 + 0.5;
}

vec3 motionToColor(vec2 motion) {
    // Visualize motion vectors as color
    // Red = horizontal motion, Green = vertical motion
    vec3 color = vec3(0.5);
    color.r = clamp(0.5 + motion.x * pc.scale, 0.0, 1.0);
    color.g = clamp(0.5 + motion.y * pc.scale, 0.0, 1.0);
    color.b = 0.5; // Neutral blue
    return color;
}

vec3 heatmapColor(float value) {
    // Create heatmap visualization
    float v = clamp(value * pc.scale, 0.0, 1.0);
    vec3 color;
    if (v < 0.5) {
        color = mix(vec3(0, 0, 0), vec3(1, 0, 0), v * 2.0);
    } else {
        color = mix(vec3(1, 0, 0), vec3(1, 1, 0), (v - 0.5) * 2.0);
    }
    if (v > 0.9) {
        color = vec3(1, 1, 1); // White for hottest areas
    }
    return color;
}

vec3 lightingContributionColor(vec2 uv) {
    // Sample lighting contribution buffers
    vec3 direct = texture(directLightBuffer, uv).rgb;
    vec3 indirect = texture(indirectLightBuffer, uv).rgb;
    vec3 lightmap = texture(lightmapBuffer, uv).rgb;

    // Calculate total luminance for each component
    float directLum = dot(direct, vec3(0.299, 0.587, 0.114));
    float indirectLum = dot(indirect, vec3(0.299, 0.587, 0.114));
    float lightmapLum = dot(lightmap, vec3(0.299, 0.587, 0.114));

    // Normalize contributions
    float total = directLum + indirectLum + lightmapLum;
    if (total > 0.001) {
        directLum /= total;
        indirectLum /= total;
        lightmapLum /= total;
    } else {
        // Default to showing test pattern if no lighting
        directLum = 0.33;
        indirectLum = 0.33;
        lightmapLum = 0.34;
    }

    // Map to RGB channels
    // Red = Direct lighting
    // Green = Indirect/GI lighting
    // Blue = Lightmap
    return vec3(directLum, indirectLum, lightmapLum);
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    // Get output dimensions
    ivec2 imageSize = imageSize(overlayImage);

    // Check bounds
    if (coord.x >= imageSize.x || coord.y >= imageSize.y) {
        return;
    }

    // Calculate UV coordinates
    vec2 uv = (vec2(coord) + 0.5) / vec2(imageSize);

    vec4 outputColor = vec4(0.0);

    // Select debug visualization based on mode
    switch (pc.debugMode) {
        case 0: // Off - pass through RT output
            outputColor = texture(rtOutput, uv);
            break;

        case 1: // Depth visualization
            float depth = texture(depthBuffer, uv).r;
            outputColor = vec4(depthToColor(depth), 1.0);
            break;

        case 2: // Normal visualization
            vec3 normal = texture(normalBuffer, uv).xyz * 2.0 - 1.0;
            outputColor = vec4(normalToColor(normal), 1.0);
            break;

        case 3: // Motion vector visualization
            vec2 motion = texture(motionVectors, uv).xy;
            outputColor = vec4(motionToColor(motion), 1.0);
            break;

        case 4: // RT output with threshold highlight
            vec4 rtSample = texture(rtOutput, uv);
            if (length(rtSample.rgb) > pc.threshold) {
                // Highlight areas above threshold
                rtSample.rgb = mix(rtSample.rgb, vec3(1, 0, 1), 0.5);
            }
            outputColor = rtSample;
            break;

        case DEBUG_MODE_HEATMAP: // Performance heatmap
            vec4 rtHeatmap = texture(rtOutput, uv);
            float metric = dot(rtHeatmap.rgb, vec3(0.299, 0.587, 0.114));
            outputColor = vec4(heatmapColor(metric), 1.0);
            break;

        case DEBUG_MODE_LIGHTING_CONTRIB: // Lighting contributions
            // Debug: First check if we can output anything at all
            // outputColor = vec4(1.0, 0.0, 1.0, 1.0); // Magenta test pattern

            // Try to read and visualize the lighting contributions
            vec3 lightContrib = lightingContributionColor(uv);

            // If all zeros, show a test pattern to verify the mode is working
            if (length(lightContrib) < 0.001) {
                // Show gradient test pattern: red left to right, green top to bottom
                outputColor = vec4(uv.x, uv.y, 0.5, 1.0);
            } else {
                outputColor = vec4(lightContrib, 1.0);
            }
            break;

        case DEBUG_MODE_MATERIAL_PROPS: // Material properties (placeholder)
            // TODO: Implement material property visualization
            outputColor = vec4(0.5, 0.5, 0.5, 1.0);
            break;

        case DEBUG_MODE_RAY_DENSITY: // Ray density (placeholder)
            // TODO: Implement ray density visualization
            outputColor = vec4(0.3, 0.3, 0.8, 1.0);
            break;

        default:
            outputColor = vec4(1, 0, 1, 1); // Magenta for unknown mode
            break;
    }

    // Optional: Add grid overlay for debugging
    if ((pc.flags & 1u) != 0u) {
        if (coord.x % 32 == 0 || coord.y % 32 == 0) {
            outputColor.rgb = mix(outputColor.rgb, vec3(0.5), 0.3);
        }
    }

    // Write final debug visualization
    imageStore(overlayImage, coord, outputColor);
}