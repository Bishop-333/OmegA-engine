/*
===========================================================================
Copyright (C) 2024 Quake3e-HD Project

RTX Ray Generation Shader
Main entry point for ray tracing
===========================================================================
*/

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0, rgba32f) uniform image2D albedoImage;
layout(binding = 3, set = 0, rgba32f) uniform image2D normalImage;
layout(binding = 4, set = 0, rgba32f) uniform image2D motionVectorImage;
layout(binding = 5, set = 0, r32f) uniform image2D depthImage;

// Lighting contribution buffers for debug visualization
layout(binding = 15, set = 0, rgba32f) uniform image2D directLightImage;
layout(binding = 16, set = 0, rgba32f) uniform image2D indirectLightImage;
layout(binding = 17, set = 0, rgba32f) uniform image2D lightmapImage;

layout(binding = 6, set = 0) uniform CameraBuffer {
    mat4 viewInverse;
    mat4 projInverse;
    vec3 position;
    float time;
    vec3 forward;
    float fov;
    vec3 right;
    float nearPlane;
    vec3 up;
    float farPlane;
    vec2 jitter;
    vec2 previousJitter;
    mat4 previousViewProjection;
    uint frameCount;
    uint enablePathTracing;
    uint maxBounces;
    uint samplesPerPixel;
} cam;

layout(binding = 7, set = 0) uniform RenderSettings {
    uint enableShadows;
    uint enableReflections;
    uint enableGI;
    uint enableAO;
    float shadowBias;
    float reflectionRoughnessCutoff;
    float giIntensity;
    float aoRadius;
    uint debugMode;
    uint enableDenoiser;
    uint enableDLSS;
    uint enableMotionBlur;
} settings;

// Ray payload for primary rays
layout(location = 0) rayPayloadEXT struct HitInfo {
    vec3 color;
    float distance;
    vec3 normal;
    float roughness;
    vec3 albedo;
    float metallic;
    vec3 worldPos;
    uint materialID;
    vec2 uv;
    uint primitiveID;
    uint instanceID;
    uint hitType; // 0 = miss, 1 = hit
} hitInfo;

// Ray payload for shadow rays
layout(location = 1) rayPayloadEXT float shadowPayload;

// Constants
const float PI = 3.14159265359;
const float INV_PI = 0.31830988618;
const float EPSILON = 0.001;

// Random number generation using PCG hash
uint pcgHash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float randomFloat(inout uint seed) {
    seed = pcgHash(seed);
    return float(seed) / 4294967296.0;
}

vec3 randomInUnitSphere(inout uint seed) {
    vec3 p;
    do {
        p = vec3(randomFloat(seed), randomFloat(seed), randomFloat(seed)) * 2.0 - 1.0;
    } while (dot(p, p) >= 1.0);
    return p;
}

vec3 randomCosineDirection(vec3 normal, inout uint seed) {
    float r1 = randomFloat(seed);
    float r2 = randomFloat(seed);
    
    float phi = 2.0 * PI * r1;
    float x = cos(phi) * sqrt(r2);
    float y = sin(phi) * sqrt(r2);
    float z = sqrt(1.0 - r2);
    
    // Build orthonormal basis
    vec3 w = normal;
    vec3 u = normalize(cross(abs(w.x) > 0.1 ? vec3(0, 1, 0) : vec3(1, 0, 0), w));
    vec3 v = cross(w, u);
    
    return normalize(u * x + v * y + w * z);
}

float luminance(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

vec3 hashColor(uint id) {
    vec3 seed = vec3(float(id) + 1.0f, (float(id) + 1.0f) * 1.321f, (float(id) + 1.0f) * 1.123f);
    return fract(sin(seed) * 43758.5453f);
}

vec3 heatmapColor(float value) {
    float v = clamp(value, 0.0, 1.0);
    vec3 color;
    if (v < 0.25) {
        color = mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.5, 1.0), v * 4.0);
    } else if (v < 0.5) {
        color = mix(vec3(0.0, 0.5, 1.0), vec3(0.0, 1.0, 0.0), (v - 0.25) * 4.0);
    } else if (v < 0.75) {
        color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (v - 0.5) * 4.0);
    } else {
        color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (v - 0.75) * 4.0);
    }

    if (v > 0.95) {
        color = vec3(1.0, 1.0, 1.0);
    }

    return color;
}

vec2 getPixelJitter(uint frameCount, uint pixelIndex) {
    uint seed = pixelIndex + frameCount * 1024;
    return vec2(randomFloat(seed), randomFloat(seed)) - 0.5;
}

void main() {
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    
    // Apply temporal jitter for TAA/DLSS
    vec2 jitteredUV = inUV;
    if (settings.enableDLSS > 0) {
        uint pixelIndex = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
        vec2 jitter = getPixelJitter(cam.frameCount, pixelIndex) / vec2(gl_LaunchSizeEXT.xy);
        jitteredUV += jitter;
    }
    
    vec2 d = jitteredUV * 2.0 - 1.0;
    vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);
    
    // Setup ray
    uint rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin = 0.001;
    float tMax = 10000.0;
    
    // Initialize random seed for this pixel
    uint pixelIndex = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
    uint rngSeed = pixelIndex + cam.frameCount * 113;
    
    vec3 finalColor = vec3(0.0);
    vec3 finalAlbedo = vec3(0.0);
    vec3 finalNormal = vec3(0.0);
    float finalDepth = 1.0;

    // Separate lighting contributions for debug visualization
    vec3 finalDirectLight = vec3(0.0);
    vec3 finalIndirectLight = vec3(0.0);
    vec3 finalLightmap = vec3(0.0);
    
    // Multi-sample anti-aliasing through multiple rays
    uint samples = cam.samplesPerPixel > 0 ? cam.samplesPerPixel : 1;
    
    for (uint s = 0; s < samples; s++) {
        // Reset hit info
        hitInfo.color = vec3(0.0);
        hitInfo.distance = -1.0;
        hitInfo.hitType = 0;
        
        // Trace primary ray
        traceRayEXT(topLevelAS,           // acceleration structure
                    rayFlags,              // rayFlags
                    0xff,                  // cullMask
                    0,                     // sbtRecordOffset
                    0,                     // sbtRecordStride
                    0,                     // missIndex
                    cam.position,          // ray origin
                    tMin,                  // ray min range
                    direction.xyz,         // ray direction
                    tMax,                  // ray max range
                    0                      // payload location
                    );
        
        if (hitInfo.hitType == 1) {
            vec3 color = vec3(0.0);
            vec3 directLight = vec3(0.0);
            vec3 indirectLight = vec3(0.0);
            vec3 lightmapContrib = vec3(0.0);

            // Direct lighting
            vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));
            float NdotL = max(dot(hitInfo.normal, lightDir), 0.0);

            // Shadow ray
            if (settings.enableShadows > 0 && NdotL > 0.0) {
                shadowPayload = 1.0;
                traceRayEXT(topLevelAS,
                           gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
                           0xff,
                           0,
                           0,
                           1,  // miss index for shadow
                           hitInfo.worldPos + hitInfo.normal * settings.shadowBias,
                           0.001,
                           lightDir,
                           10000.0,
                           1   // shadow payload location
                           );
                NdotL *= shadowPayload;
            }

            // Calculate direct lighting contribution
            directLight = hitInfo.albedo * NdotL;
            color = directLight;

            // Ambient/Lightmap contribution (simulated for now)
            lightmapContrib = hitInfo.albedo * 0.1;
            color += lightmapContrib;
            
            // Global illumination
            if (settings.enableGI > 0 && cam.maxBounces > 0) {
                vec3 giColor = vec3(0.0);
                uint giSamples = 4;

                for (uint gi = 0; gi < giSamples; gi++) {
                    vec3 giDir = randomCosineDirection(hitInfo.normal, rngSeed);

                    // Trace GI ray
                    HitInfo giHit;
                    traceRayEXT(topLevelAS,
                               rayFlags,
                               0xff,
                               0, 0, 0,
                               hitInfo.worldPos + hitInfo.normal * 0.01,
                               0.01,
                               giDir,
                               100.0,
                               0);

                    if (giHit.hitType == 1) {
                        giColor += giHit.albedo * 0.5;
                    }
                }

                // Calculate indirect lighting contribution
                indirectLight = (giColor / float(giSamples)) * settings.giIntensity * hitInfo.albedo;
                color += indirectLight;
            }
            
            // Reflections
            if (settings.enableReflections > 0 && hitInfo.roughness < settings.reflectionRoughnessCutoff) {
                vec3 reflectDir = reflect(normalize(direction.xyz), hitInfo.normal);
                
                HitInfo reflectHit;
                traceRayEXT(topLevelAS,
                           rayFlags,
                           0xff,
                           0, 0, 0,
                           hitInfo.worldPos + hitInfo.normal * 0.01,
                           0.01,
                           reflectDir,
                           1000.0,
                           0);
                
                if (reflectHit.hitType == 1) {
                    float fresnel = pow(1.0 - max(dot(-normalize(direction.xyz), hitInfo.normal), 0.0), 2.0);
                    color = mix(color, reflectHit.albedo, fresnel * (1.0 - hitInfo.roughness));
                }
            }
            
            finalColor += color;
            finalAlbedo += hitInfo.albedo;
            finalNormal += hitInfo.normal;
            finalDepth = min(finalDepth, hitInfo.distance / cam.farPlane);

            // Accumulate lighting contributions
            finalDirectLight += directLight;
            finalIndirectLight += indirectLight;
            finalLightmap += lightmapContrib;
        } else {
            // Sky color
            float t = 0.5 * (normalize(direction.xyz).y + 1.0);
            vec3 skyColor = mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.7, 1.0), t);
            finalColor += skyColor;
        }
    }
    
    // Average samples
    finalColor /= float(samples);
    finalAlbedo /= float(samples);
    finalNormal = normalize(finalNormal);
    finalDirectLight /= float(samples);
    finalIndirectLight /= float(samples);
    finalLightmap /= float(samples);
    
    // Calculate motion vectors for temporal effects
    vec2 motionVector = vec2(0.0);
    if (settings.enableMotionBlur > 0 || settings.enableDLSS > 0) {
        if (hitInfo.hitType == 1) {
            vec4 currentPos = cam.viewInverse * vec4(hitInfo.worldPos, 1.0);
            vec4 previousPos = cam.previousViewProjection * vec4(hitInfo.worldPos, 1.0);
            
            vec2 currentScreen = (currentPos.xy / currentPos.w) * 0.5 + 0.5;
            vec2 previousScreen = (previousPos.xy / previousPos.w) * 0.5 + 0.5;
            
            motionVector = currentScreen - previousScreen;
        }
    }
    
    // Debug visualization modes
    if (settings.debugMode > 0) {
        switch (settings.debugMode) {
            case 1: // RT participation heuristic
                if (hitInfo.hitType == 0u) {
                    finalColor = vec3(0.6, 0.0, 0.0);
                } else {
                    float roughnessWeight = clamp(1.0 - hitInfo.roughness, 0.0, 1.0);
                    vec3 base = mix(vec3(0.0, 0.3, 0.0), vec3(0.0, 0.9, 0.0), roughnessWeight);
                    float metallicWeight = clamp(hitInfo.metallic, 0.0, 1.0);
                    vec3 reflective = vec3(0.0, 0.8, 0.8);
                    finalColor = mix(base, reflective, metallicWeight);
                }
                break;
            case 2: // Material properties (roughness/metallic/emissive proxy)
                {
                    float litLuminance = luminance(finalDirectLight + finalIndirectLight + finalLightmap);
                    float emissive = clamp(luminance(finalColor) - litLuminance, 0.0, 1.0);
                    finalColor = vec3(hitInfo.roughness, hitInfo.metallic, emissive);
                }
                break;
            case 3: // Lighting contributions (direct / indirect / lightmap)
                {
                    float directLum = luminance(finalDirectLight);
                    float indirectLum = luminance(finalIndirectLight);
                    float lightmapLum = luminance(finalLightmap);
                    float total = max(directLum + indirectLum + lightmapLum, 1e-5);
                    finalColor = vec3(directLum, indirectLum, lightmapLum) / total;
                }
                break;
            case 4: // Ray density proxy using distance heatmap
                {
                    float density = (hitInfo.hitType == 0u) ? 0.0 : 1.0 / (hitInfo.distance + 1.0);
                    finalColor = heatmapColor(density * 2.0);
                }
                break;
            case 5: // Surface normals
                finalColor = finalNormal * 0.5 + 0.5;
                break;
            case 6: // Lightmap coverage approximation
                {
                    float lightmapLum = luminance(finalLightmap);
                    finalColor = vec3(lightmapLum);
                }
                break;
            case 7: // Instance identifiers
                finalColor = hashColor(hitInfo.instanceID);
                break;
            case 8: // Random verification noise
            {
                uint pixelId = gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x;
                finalColor = hashColor(pixelId + cam.frameCount * 733u);
                break;
            }
            default:
                finalColor = finalAlbedo;
                break;
        }
    }
    
    // Store outputs
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.0));
    imageStore(albedoImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalAlbedo, 1.0));
    imageStore(normalImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalNormal * 0.5 + 0.5, 1.0));
    imageStore(motionVectorImage, ivec2(gl_LaunchIDEXT.xy), vec4(motionVector, 0.0, 1.0));
    imageStore(depthImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalDepth, 0.0, 0.0, 1.0));

    // Store lighting contributions for debug visualization
    imageStore(directLightImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalDirectLight, 1.0));
    imageStore(indirectLightImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalIndirectLight, 1.0));
    imageStore(lightmapImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalLightmap, 1.0));
}
